// Constant definitions

#define SHORT_PI        3.1416
#define PI              3.141592653589793238462643383279502884197169399375105820974944592308
#define EPSILON         1E-10


// Type definitions

typedef enum {CW, CCW, COL}							spinType;
typedef enum {CONCAVE, CONVEX, COLLINEAR}			angleType;
typedef enum {NORMAL, INTER, DOUBLE, SPLIT, VISITED, MATCH_1, MATCH_2}	vectorType;

// Data structures for geometry concepts

// SEGMENT
typedef struct segmentStruct
{
	int			info;
	int			vertex1;
	int			vertex2;
} segmentStruct;

typedef segmentStruct* segmentPtr;

// VECTOR
typedef struct vectorStruct
{
	int			vectorId;
	double		i;
	double		j;
	double		k;
	vectorType	type;
	int			num_intersections;
} vectorStruct;

typedef vectorStruct* vectorPtr;




// Find the smallest of two numbers
double getMin (double first, double second);

// Find the largest of two numbers
double getMax (double first, double second);

double distance2Vertices (vertexStruct vertex1, vertexStruct vertex2);

// Returns the square of the distance between 2 vertices.
double squareDistance (vertexStruct vertex1, vertexStruct vertex2);

// Allocate memory and fill in the data for a segment structure.
segmentPtr createSegment (int vertex1, int vertex2, int info);

// Find the components of a vector, enclosed between two vertices.
vectorPtr vectorFromVertices (vertexPtr vertex1, vertexPtr vertex2);

// Find the angle formed by three vertices, by creating 2 vectors.
double angleBetweenVertices (vertexStruct vertex1, vertexStruct vertex2, vertexStruct vertex3);

// Compute the angle between two vectors.
double angleBetweenVectors (vectorPtr vector1, vectorPtr vector2);

// Test if the coordinates of two vertices are the same.
// Done based on the distance between both, given some tolerance.
boolean equalVertices (vertexStruct vertex1, vertexStruct vertex2);

// Test whether a vector is equal to zero.
// In most cases, this is incorrect.
boolean vector_equal_to_zero (vectorPtr vector);

// Determine if two vectors have the same direction,
//  within a certain tolerance.
boolean equalVectors (vectorPtr vector1, vectorPtr vector2);

// Determine if two vectors have the same direction,
//  within a certain larger tolerance.
boolean relaxedEqualVectors (vectorPtr vector1, vectorPtr vector2);

// Determine if two vectors are equal or opposite,
//  based on the angle between them.
boolean colinearVectors (vectorPtr vector1, vectorPtr vector2);

// Obtain the dot product of two vectors.
double dotProduct (vectorPtr vector1, vectorPtr vector2);

// Compute the cross product of two vectors.
vectorPtr crossProduct (vectorPtr vector1, vectorPtr vector2);

// Sum two vectors.
vectorPtr sumVectors (vectorPtr vector1, vectorPtr vector2);

// Alter the size of a normal vector, to make it equal to 1.
void normalizeVector (vectorPtr vector);

// Compute the length of a vector.
double vectorLength (vectorPtr vector);

// Get the orientation of the triangle formed by three vertices.
// This is done by obtaining the slopes of the two segments generated by the vertices.
spinType orientationFromVertices_2D (vertexStruct vertex1, vertexStruct vertex2, vertexStruct vertex3);

// Get the orientation of the triangle formed by three vertices.
// Since the vertices can lie in any plane, the normal vector
//  to the plane is used to determine their orientation.
spinType orientationFromVertices_3D (vertexStruct vertex1, vertexStruct vertex2, vertexStruct vertex3, vectorStruct normal_vector);

// Check whether two segments intersect each other.
boolean testSegmentsIntersect_2D (vertexStruct vertexA1, vertexStruct vertexA2, vertexStruct vertexB1, vertexStruct vertexB2);

// Check whether two segments intersect each other.
boolean testSegmentsIntersect_NotInclusive_2D (vertexStruct vertexA1, vertexStruct vertexA2, vertexStruct vertexB1, vertexStruct vertexB2);

// Test whether a segment intersects any of the segments in a curve.
boolean testSegmentCurveIntersect (vertexPtr vertexArray, nodePtr curve, vertexStruct vertex1, vertexStruct vertex2);

// Check which of two collinear vertices is farther from a reference vertex
// Returns the vertexId of the vertex that is farther away.
int findFarCollinearVertex (vertexStruct vertex1, vertexStruct vertex2, vertexStruct vertex3);

// Find the distance from a vertex to the segment defined within two other vertices.
// It returns the distance if the vertex is in front of the segment. If not, returns -1.
double distanceVertexToSegment (vertexStruct vertex, vertexStruct segmentVertex1, vertexStruct segmentVertex2);

// Print the contents of a list of vectors.
void printVectorList (nodePtr list);

// Project a single vertex on a plane, along the normal of the plane.
// Takes as parameters the normal of the plane and a vertex in its surface,
//  and the vertex to be projected.
// Returns a new vertex in the variable 'projected_vertex'.
vertexStruct project_vertex_on_plane (vectorStruct plane_normal, vertexStruct plane_vertex, vertexStruct original_vertex);

// Divide a polygon in a plane into triangles.
nodePtr triangulateFlatPolygon (vertexPtr vertexArray, nodePtr polygonList, vectorStruct plane_normal, nodePtr triangulation);

// Divide a polygon into two simpler polygons.
// The division is done by drawing a diagonal between two
//  vertices of the polygon. These two vertices will now
//  belong to both of the polygons.
void divideFlatPolygon (vertexPtr vertexArray, nodePtr polygonList, nodePtr* part1List, nodePtr* part2List, vectorStruct plane_normal);

// Determine if a vertex is inside of a triangle.
// Returns true if the point is inside.
boolean pointInsideFlatTriangle (vertexStruct vertex1, vertexStruct vertex2, vertexStruct vertex3, vertexStruct vertex4, vectorStruct plane_normal);

// area3D_Polygon(): computes the area of a 3D planar polygon
//    Return: the (double) area of the polygon
double area3D_Polygon( int num_vertices, vertexPtr vertex_array, vertexStruct normal_vector );
